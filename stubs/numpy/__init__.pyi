# pylint: skip-file

from collections.abc import Collection, Iterator, Sequence
from typing import (
    Any,
    BinaryIO,
    Generic,
    Literal,
    TypeAlias,
    TypeVar,
    TypeVarTuple,
    overload,
)

from jax import Device

from . import linalg as linalg
from . import ma as ma
from . import random as random
from . import testing as testing

Shape = TypeVarTuple("Shape")
Shape2 = TypeVarTuple("Shape2")
Shape3 = TypeVarTuple("Shape3")
DType = TypeVar("DType")
DType2 = TypeVar("DType2")
Dim1 = TypeVar("Dim1", bound=int)
Dim2 = TypeVar("Dim2", bound=int)
Dim3 = TypeVar("Dim3", bound=int)
One = Literal[1]
Float = TypeVar("Float", bound=float)
Float2 = TypeVar("Float2", bound=float)
Int = TypeVar("Int", bound=int)
Left = TypeVar("Left", bound=int)
Right = TypeVar("Right", bound=int)

Twice: TypeAlias = Sum[Int, Int]

class Sum(int, Generic[*Shape]): ...
class Product(int, Generic[*Shape]): ...
class Fin(int, Generic[Int]): ...

class ndarray(Generic[*Shape, DType]):
    dtype: type[DType]
    nbytes: int
    ndim: int
    def item(self: ndarray[DType]) -> DType: ...
    def block_until_ready(self) -> None: ...

    class at_res(Generic[*Shape2, DType2]):
        @overload
        def __getitem__(
            self: ndarray.at_res[Dim1, Dim2, DType2], key: tuple[ellipsis, ndarray[Dim1, Fin[Dim2]]]
        ) -> ndarray.at_ops[Dim1, Dim2, DType2]: ...
        @overload
        def __getitem__(
            self: ndarray.at_res[Dim1, Dim2, DType2],
            key: tuple[ndarray[Dim1, Fin[Dim1]], ndarray[Dim1, Fin[Dim2]]],
        ) -> ndarray.at_ops[Dim1, Dim2, DType2]: ...
        @overload
        def __getitem__(self, key: tuple[ellipsis, int]) -> ndarray.at_ops[*Shape2, DType2]: ...
        @overload
        def __getitem__(self, key: slice) -> ndarray.at_ops[*Shape2, DType2]: ...
        @overload
        def __getitem__(self, key: ndarray[*Shape2, bool]) -> ndarray.at_ops[*Shape2, DType2]: ...
        @overload
        def __getitem__(
            self: ndarray.at_res[Dim1, *Shape3, DType2], key: tuple[ndarray[Fin[Dim1]], ellipsis]
        ) -> ndarray.at_ops[Dim1, *Shape3, DType2]: ...

    class at_ops(Generic[*Shape2, DType2]):
        def multiply(self, x: float) -> ndarray[*Shape2, DType2]: ...
        @overload
        def set(self, x: DType2) -> ndarray[*Shape2, DType2]: ...
        @overload
        def set(self, x: ndarray[DType2]) -> ndarray[*Shape2, DType2]: ...

    at: ndarray.at_res[*Shape, DType]
    def __contains__(self, item: DType) -> bool: ...
    def __neg__(self: ndarray[*Shape, DType]) -> ndarray[*Shape, DType]: ...
    def __pow__(self: ndarray[*Shape, float], other: float) -> ndarray[*Shape, float]: ...
    def __and__(self: ndarray[*Shape, bool], other: ndarray[*Shape, bool]) -> ndarray[*Shape, bool]: ...
    def __invert__(self: ndarray[*Shape, bool]) -> ndarray[*Shape, bool]: ...
    def __len__(self) -> int: ...
    @overload
    def __ne__(self, other: DType) -> ndarray[*Shape, bool]: ...
    @overload
    def __ne__(self, other: int) -> ndarray[*Shape, bool]: ...
    @overload
    def __ne__(self: ndarray[*Shape, bool], other: ndarray[*Shape, bool]) -> ndarray[*Shape, bool]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @overload
    def __eq__(self: ndarray[Dim1, One, DType], other: ndarray[One, Dim2, DType]) -> ndarray[Dim1, Dim2, bool]: ...
    @overload
    def __eq__(self: ndarray[*Shape, bool], other: ndarray[*Shape, float]) -> ndarray[*Shape, bool]: ...
    @overload
    def __eq__(self: ndarray[*Shape, DType], other: ndarray[*Shape, DType]) -> ndarray[*Shape, bool]: ...
    @overload
    def __eq__(self, other: DType) -> ndarray[*Shape, bool]: ...
    @overload
    def __eq__(self, other: int) -> ndarray[*Shape, bool]: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    def __ior__(self: ndarray[*Shape, bool], other: ndarray[*Shape, bool]) -> ndarray[*Shape, bool]: ...
    def __or__(self: ndarray[*Shape, bool], other: ndarray[*Shape, bool]) -> ndarray[*Shape, bool]: ...
    @overload
    def __lt__(self: ndarray[*Shape, Float], other: ndarray[*Shape, Float]) -> ndarray[*Shape, bool]: ...
    @overload
    def __lt__(self: ndarray[*Shape, Float], other: Float2) -> ndarray[*Shape, bool]: ...
    @overload
    def __lt__(self: ndarray[*Shape, Float], other: ndarray[Float2]) -> ndarray[*Shape, bool]: ...
    @overload
    def __gt__(self, other: Float) -> ndarray[*Shape, bool]: ...
    @overload
    def __gt__(self: ndarray[*Shape, Float], other: int) -> ndarray[*Shape, bool]: ...
    @overload
    def __gt__(self: ndarray[*Shape, Float], other: ndarray[Float]) -> ndarray[*Shape, bool]: ...
    @overload
    def __ge__(self, other: DType) -> ndarray[*Shape, bool]: ...
    @overload
    def __ge__(self, other: ndarray[DType]) -> ndarray[*Shape, bool]: ...
    @overload
    def __ge__(self: ndarray[*Shape, int], other: float) -> ndarray[*Shape, bool]: ...
    @overload
    def __ge__(self, other: ndarray[*Shape, DType]) -> ndarray[*Shape, bool]: ...
    @overload
    def __add__(self: ndarray[*Shape, Float], other: Float | int | ndarray[Float]) -> ndarray[*Shape, Float]: ...
    @overload
    def __add__(self, other: ndarray[*Shape, DType]) -> ndarray[*Shape, DType]: ...
    @overload
    def __add__(
        self: ndarray[Dim1, *Shape2, DType2], other: ndarray[*Shape2, DType2]
    ) -> ndarray[Dim1, *Shape2, DType2]: ...
    @overload
    def __add__(
        self: ndarray[Dim1, float],
        other: ndarray[Dim2, Literal[1], float],
    ) -> ndarray[Dim2, Dim1, float]: ...
    @overload
    def __radd__(self, other: DType) -> ndarray[*Shape, DType]: ...
    @overload
    def __radd__(self, other: int) -> ndarray[*Shape, DType]: ...
    @overload
    def __sub__(
        self: ndarray[*Shape2, Dim1, DType2], other: ndarray[*Shape2, One, DType2]
    ) -> ndarray[*Shape2, Dim1, DType2]: ...
    @overload
    def __sub__(self, other: ndarray[*Shape, DType]) -> ndarray[*Shape, DType]: ...
    @overload
    def __sub__(self, other: ndarray[int]) -> ndarray[*Shape, DType]: ...
    @overload
    def __sub__(self, other: ndarray[Float]) -> ndarray[*Shape, DType]: ...
    @overload
    def __sub__(self, other: float) -> ndarray[*Shape, DType]: ...
    @overload
    def __rsub__(self, other: int) -> ndarray[*Shape, DType]: ...
    @overload
    def __rsub__(self, other: ndarray[int]) -> ndarray[*Shape, DType]: ...
    @overload
    def __rmul__(self, other: ndarray[DType]) -> ndarray[*Shape, DType]: ...
    @overload
    def __rmul__(self, other: DType) -> ndarray[*Shape, DType]: ...
    @overload
    def __rmul__(self, other: float) -> ndarray[*Shape, DType]: ...
    @overload
    def __truediv__(
        self: ndarray[*Shape2, Dim1, DType2], other: ndarray[*Shape2, One, DType2]
    ) -> ndarray[*Shape2, Dim1, DType2]: ...
    @overload
    def __truediv__(self: ndarray[*Shape, float], other: int) -> ndarray[*Shape, float]: ...
    @overload
    def __truediv__(self: ndarray[*Shape, int], other: ndarray[*Shape, int] | int) -> ndarray[*Shape, float]: ...
    @overload
    def __truediv__(self: ndarray[*Shape, Float], other: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...
    @overload
    def __truediv__(
        self: ndarray[Dim1, Dim2, float], other: ndarray[Dim2, float]
    ) -> ndarray[Dim1, Dim2, float]: ...
    @overload
    def __truediv__(
        self: ndarray[*Shape, Float] | ndarray[*Shape, int], other: int | Float | ndarray[Float]
    ) -> ndarray[*Shape, Float]: ...
    def __rtruediv__(
        self: ndarray[*Shape, int] | ndarray[*Shape, Float], other: int | Float | ndarray[Float]
    ) -> ndarray[*Shape, Float]: ...
    @overload
    def __mul__(self, other: DType) -> ndarray[*Shape, DType]: ...
    @overload
    def __mul__(self, other: ndarray[DType]) -> ndarray[*Shape, DType]: ...
    @overload
    def __mul__(self: ndarray[*Shape, DType], other: float) -> ndarray[*Shape, DType]: ...
    @overload
    def __mul__(self, other: ndarray[*Shape, DType]) -> ndarray[*Shape, DType]: ...
    @overload
    def __mul__(
        self: ndarray[*Shape, Float], other: ndarray[*Shape, int] | ndarray[*Shape, Float]
    ) -> ndarray[*Shape, Float]: ...
    @overload
    def __mul__(
        self: ndarray[Dim1, One, DType], other: ndarray[One, Dim2, DType]
    ) -> ndarray[Dim1, Dim2, DType]: ...
    @overload
    def __mul__(
        self: ndarray[One, Dim2, One, DType], other: ndarray[Dim1, Dim2, Dim3, DType]
    ) -> ndarray[Dim1, Dim2, Dim3, DType]: ...
    def astype(self, dtype: type[DType2]) -> ndarray[*Shape, DType2]: ...
    @overload
    def __getitem__(
        self: ndarray[Dim1, Dim2, DType], key: tuple[ndarray[Dim1, bool], int]
    ) -> ndarray[int, DType]: ...
    @overload
    def __getitem__(self: ndarray[Dim1, *Shape2, DType], key: tuple[int, ellipsis]) -> ndarray[*Shape2, DType]: ...
    @overload
    def __getitem__(
        self: ndarray[Dim1, Dim1, DType], key: tuple[ndarray[Dim2, Fin[Dim1]], ndarray[Dim2, Fin[Dim1]]]
    ) -> ndarray[Dim2, DType]: ...
    @overload
    def __getitem__(
        self: ndarray[Dim1, *Shape2, DType], key: tuple[ndarray[Fin[Dim1]], ellipsis]
    ) -> ndarray[*Shape2, DType]: ...
    @overload
    def __getitem__(
        self: ndarray[Dim1, Dim2, Dim3, DType], key: tuple[int, int, ellipsis]
    ) -> ndarray[Dim3, DType]: ...
    @overload
    def __getitem__(
        self: ndarray[Dim1, Dim2, Dim3, DType], key: tuple[int, ndarray[Fin[Dim2]], ellipsis]
    ) -> ndarray[Dim3, DType]: ...
    @overload
    def __getitem__(self: ndarray[Dim1, DType], key: ndarray[Dim1, bool]) -> ndarray[int, DType]: ...
    @overload
    def __getitem__(self: ndarray[Dim1, DType], key: ndarray[*Shape2, Fin[Dim1]]) -> ndarray[*Shape2, DType]: ...
    @overload
    def __getitem__(self: ndarray[Dim1, DType], key: int) -> DType: ...
    @overload
    def __getitem__(
        self: ndarray[Dim1, *Shape, DType], key: tuple[ndarray[Dim3, Fin[Dim1]], ellipsis]
    ) -> ndarray[Dim3, *Shape, DType]: ...
    @overload
    def __getitem__(
        self: ndarray[Dim1, *Shape2, DType], key: tuple[ndarray[Dim1, bool], ellipsis]
    ) -> ndarray[int, *Shape2, DType]: ...
    @overload
    def __getitem__(self: ndarray[*Shape2, Dim1, DType], key: tuple[ellipsis, int]) -> ndarray[*Shape2, DType]: ...
    @overload
    def __getitem__(self: ndarray[Dim1, Dim2, DType], key: tuple[int, int]) -> DType: ...
    @overload
    def __getitem__(self: ndarray[Dim1, DType], key: slice) -> ndarray[int, DType]: ...
    @overload
    def __getitem__(
        self: ndarray[*Shape2, Dim1, DType], key: tuple[ellipsis, slice]
    ) -> ndarray[*Shape2, int, DType]: ...
    @overload
    def __getitem__(
        self: ndarray[Dim1, *Shape2, DType], key: tuple[slice, ellipsis]
    ) -> ndarray[int, *Shape2, DType]: ...
    @overload
    def __getitem__(
        self: ndarray[Dim1, Dim2, *Shape2, DType], key: tuple[slice, slice, ellipsis]
    ) -> ndarray[int, int, *Shape2, DType]: ...
    @overload
    def __getitem__(
        self: ndarray[Dim1, *Shape2, DType], key: tuple[ndarray[Dim2, Fin[Dim1]], ellipsis]
    ) -> ndarray[Dim2, *Shape2, DType]: ...
    @overload
    def __setitem__(self: ndarray[*Shape2, Dim1, DType], key: tuple[ellipsis, int], value: DType) -> None: ...
    @overload
    def __setitem__(
        self: ndarray[Dim1, *Shape2, DType], key: tuple[int, ellipsis], value: ndarray[DType]
    ) -> None: ...
    @overload
    def __setitem__(
        self: ndarray[Dim1, *Shape2, DType], key: tuple[int, slice], value: ndarray[*Shape2, DType]
    ) -> None: ...
    @overload
    def __setitem__(self, key: slice, value: ndarray[*Shape, DType]) -> None: ...
    @overload
    def __setitem__(self: ndarray[Dim1, DType], key: slice, value: DType) -> None: ...
    @overload
    def __setitem__(
        self: ndarray[Dim1, Dim2, DType], key: tuple[slice, slice], value: ndarray[Dim1, Dim2, DType]
    ) -> None: ...
    @overload
    def __setitem__(self, key: int, value: DType) -> None: ...
    @overload
    def __setitem__(self: ndarray[Dim1, DType], key: ndarray[int, Fin[Dim1]], value: DType) -> None: ...
    @overload
    def __setitem__(self: ndarray[Dim1, Dim2, DType], key: tuple[int, slice], value: list[DType]) -> None: ...
    @overload
    def __setitem__(
        self: ndarray[Dim1, Dim2, DType], key: tuple[slice, int], value: ndarray[Dim1, DType]
    ) -> None: ...
    @overload
    def __setitem__(
        self: ndarray[Dim1, *Shape2, DType], key: tuple[slice, ellipsis], value: ndarray[int, *Shape2, DType]
    ) -> None: ...
    @overload
    def __setitem__(
        self: ndarray[Dim1, *Shape2, DType],
        key: tuple[ndarray[int, Fin[Dim1]], ellipsis],
        value: ndarray[int, *Shape2, DType],
    ) -> None: ...
    @overload
    def __setitem__(self: ndarray[Dim1, DType], key: ndarray[Dim1, bool], value: ndarray[Dim1, DType]) -> None: ...
    @overload
    def __setitem__(self: ndarray[Dim1, DType], key: ndarray[Dim1, bool], value: Scalar) -> None: ...
    @overload
    def __setitem__(self: ndarray[Dim1, DType], key: slice, value: Sequence[DType]) -> None: ...
    @overload
    def __iter__(self: ndarray[Dim1, DType]) -> Iterator[DType]: ...  # pyright: ignore[reportOverlappingOverload]
    @overload
    def __iter__(self: ndarray[Dim1, *Shape2, DType]) -> Iterator[ndarray[*Shape2, DType]]: ...
    @property
    def shape(self: ndarray[*Shape, DType]) -> tuple[*Shape]: ...
    def max(
        self: ndarray[*Shape2, Dim1, DType], axis: Literal[-1], keepdims: Literal[True]
    ) -> ndarray[*Shape2, One, DType]: ...
    def tolist(self: ndarray[Dim1, DType]) -> list[DType]: ...
    def reshape(self, shape: tuple[*Shape2]) -> ndarray[*Shape2, DType]: ...
    size: int
    def resize(self, new_shape: tuple[*Shape], refcheck: bool = True) -> None: ...
    def copy(self) -> ndarray[*Shape, DType]: ...
    flat: Iterator[DType]
    @property
    def T(self: ndarray[Dim1, Dim2, DType]) -> ndarray[Dim2, Dim1, DType]: ...
    def __matmul__(
        self: ndarray[Dim1, Dim2, DType], other: ndarray[Dim2, Dim3, DType]
    ) -> ndarray[Dim1, Dim3, DType]: ...
    def devices(self) -> set[Device]: ...
    def __float__(self: ndarray[Float]) -> Float: ...

class integer(int):
    def __int__(self) -> int: ...

class signedinteger(integer): ...
class unsignedinteger(integer): ...

class int64(signedinteger):
    def __init__(self, value: int | str) -> None: ...

class uint64(unsignedinteger): ...

Scalar = TypeVar("Scalar", int, float)

def sort(a: ndarray[Dim1, DType]) -> ndarray[Dim1, DType]: ...
def argsort(a: ndarray[*Shape, DType], axis: int) -> ndarray[*Shape, int]: ...
def isfinite(x: ndarray[*Shape, Float]) -> ndarray[*Shape, bool]: ...
@overload
def percentile(a: ndarray[*Shape, Float] | ndarray[*Shape, int], q: float) -> ndarray[Float]: ...
@overload
def percentile(a: ndarray[*Shape, Float], q: ndarray[Dim1, float]) -> ndarray[Dim1, Float]: ...
@overload
def array(object: tuple[DType]) -> ndarray[One, DType]: ...
@overload
def array(object: Sequence[Float]) -> ndarray[int, Float]: ...
@overload
def array(object: Sequence[float | int], dtype: type[DType]) -> ndarray[Any, DType]: ...
@overload
def array(object: ndarray[*Shape, DType]) -> ndarray[*Shape, DType]: ...
@overload
def array(object: Sequence[Sequence[DType]]) -> ndarray[Any, Any, DType]: ...
@overload
def array(object: Sequence[Sequence[float]], dtype: type[DType]) -> ndarray[Any, Any, DType]: ...
@overload
def array(object: Float) -> ndarray[Float]: ...
@overload
def array(object: Float, dtype: type[DType]) -> ndarray[DType]: ...
@overload
def array(object: Sequence[ndarray[*Shape, DType]]) -> ndarray[Any, *Shape, DType]: ...
def clip(
    a: ndarray[*Shape, Float], a_min: float | ndarray[float] | None, a_max: float | ndarray[float]
) -> ndarray[*Shape, Float]: ...
def floor(x: ndarray[*Shape, float]) -> ndarray[*Shape, float]: ...
def searchsorted(a: ndarray[Dim1, Float], v: Float) -> int: ...
def ceil(x: ndarray[*Shape, float]) -> ndarray[*Shape, float]: ...
@overload
def mean(a: ndarray[*Shape, Float]) -> ndarray[Float]: ...
@overload
def mean(a: ndarray[*Shape, Dim1, Float], axis: Literal[-1]) -> ndarray[*Shape, Float]: ...
@overload
def mean(
    a: ndarray[Dim1, *Shape2, Float], axis: Literal[0], where: ndarray[Dim1, One, bool] | None = None
) -> ndarray[*Shape2, Float]: ...
@overload
def mean(
    a: ndarray[Dim1, Dim2, *Shape, Float],
    axis: Literal[1],
    where: ndarray[Dim1, Dim2, *Shape, bool] | None = None,
) -> ndarray[Dim1, *Shape, Float]: ...
@overload
def mean(a: ndarray[Dim1, Dim2, Dim3, Float], axis: tuple[Literal[1], Literal[2]]) -> ndarray[Dim1, Float]: ...
@overload
def mean(a: ndarray[Dim1, Dim2, Dim3, Float], axis: tuple[Literal[0], Literal[1]]) -> ndarray[Dim3, Float]: ...
@overload
def mean(a: ndarray[*Shape, Float], where: ndarray[*Shape, bool]) -> ndarray[Float]: ...
@overload
def mean(
    a: ndarray[Dim1, Dim2, Dim3, *Shape2, Float], where: ndarray[Dim1, Dim2, One, *Shape2, bool], axis: Literal[1]
) -> ndarray[Dim1, Dim3, *Shape2, Float]: ...
@overload
def arange(start: int, stop: int, step: int) -> ndarray[int, int]: ...
@overload
def arange(stop: Num) -> ndarray[Num, Fin[Num]]: ...
@overload
def arange(start: int, stop: int, *, dtype: type[DType]) -> ndarray[int, DType]: ...
@overload
def arange(stop: Num, *, dtype: type[DType]) -> ndarray[Num, DType]: ...
def insert(
    arr: ndarray[Dim1, *Shape, DType],
    obj: int,
    values: ndarray[*Shape, DType],
    axis: Literal[0],
) -> ndarray[Sum[One, Dim1], *Shape, DType]: ...
def vstack(tup: Sequence[ndarray[*Shape, DType]]) -> ndarray[int, *Shape, DType]: ...
@overload
def cumsum(a: ndarray[Dim1, DType]) -> ndarray[Dim1, DType]: ...
@overload
def cumsum(a: Sequence[DType]) -> ndarray[int, DType]: ...
@overload
def cumsum(a: ndarray[*Shape, bool], axis: int) -> ndarray[*Shape, int]: ...
def vsplit(
    ary: ndarray[*Shape, DType], indices_or_sections: ndarray[int, int]
) -> list[ndarray[*Shape, DType]]: ...
def dot(a: ndarray[Dim1, DType], b: ndarray[Dim1, DType]) -> DType: ...

Num = TypeVar("Num", bound=int)

def linspace(start: float, stop: float, num: Num) -> ndarray[Num, float]: ...
@overload
def zeros(shape: Dim1, dtype: type[DType] = float) -> ndarray[Dim1, DType]: ...
@overload
def zeros(shape: tuple[*Shape], dtype: type[DType] = float) -> ndarray[*Shape, DType]: ...
@overload
def ones(shape: Dim1, dtype: type[DType] = float) -> ndarray[Dim1, DType]: ...
@overload
def ones(shape: tuple[*Shape], dtype: type[DType] = float) -> ndarray[*Shape, DType]: ...
@overload
def empty(shape: Dim1, dtype: type[DType] = float) -> ndarray[Dim1, DType]: ...
@overload
def empty(shape: tuple[*Shape], dtype: type[DType] = float) -> ndarray[*Shape, DType]: ...
def nonzero(a: ndarray[Dim1, bool]) -> tuple[ndarray[Dim1, int]]: ...
def argmin(a: Sequence[DType]) -> int: ...
@overload
def where(
    condition: ndarray[*Shape, bool],
    x: ndarray[*Shape, DType] | ndarray[DType],
    y: ndarray[*Shape, DType] | ndarray[DType],
) -> ndarray[*Shape, DType]: ...
@overload
def where(
    condition: ndarray[Dim1, One, bool], x: ndarray[DType], y: ndarray[Dim1, Dim2, DType]
) -> ndarray[Dim1, Dim2, DType]: ...
@overload
def full(shape: tuple[*Shape], fill_value: DType) -> ndarray[*Shape, DType]: ...
@overload
def full(shape: tuple[*Shape], fill_value: float, dtype: type[DType]) -> ndarray[*Shape, DType]: ...
def sin(x: ndarray[*Shape, float]) -> ndarray[*Shape, float]: ...
def cos(x: ndarray[*Shape, float]) -> ndarray[*Shape, float]: ...
@overload
def stack(arrays: tuple[ndarray[*Shape, DType], ndarray[*Shape, DType]]) -> ndarray[Literal[2], *Shape, DType]: ...  # pyright: ignore[reportOverlappingOverload]
@overload
def stack(arrays: Sequence[ndarray[*Shape, DType]], axis: Literal[0] = 0) -> ndarray[int, *Shape, DType]: ...
@overload
def stack(arrays: Sequence[ndarray[*Shape, DType]], axis: Literal[-1]) -> ndarray[*Shape, int, DType]: ...
def log(x: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...
@overload
def sum(x: ndarray[*Shape, Float]) -> ndarray[Float]: ...
@overload
def sum(x: ndarray[*Shape, Float], where: ndarray[*Shape, bool]) -> ndarray[Float]: ...
@overload
def sum(x: ndarray[*Shape, Dim1, Float], axis: Literal[-1]) -> ndarray[*Shape, Float]: ...
@overload
def sum(
    x: ndarray[*Shape, Dim1, Float], axis: Literal[-1], keepdims: Literal[True]
) -> ndarray[*Shape, One, Float]: ...
@overload
def sum(x: ndarray[Dim1, Dim2, *Shape, Float], axis: Literal[1]) -> ndarray[Dim1, *Shape, Float]: ...
@overload
def sum(
    x: ndarray[Dim1, Dim2, *Shape, Float], axis: Literal[1], keepdims: Literal[True]
) -> ndarray[Dim1, One, *Shape, Float]: ...
def ravel(a: ndarray[*Shape, DType]) -> ndarray[Product[*Shape], DType]: ...
@overload
def expand_dims(
    a: ndarray[*Shape, Dim1, Dim2, DType], axis: Literal[-3]
) -> ndarray[*Shape, Literal[1], Dim1, Dim2, DType]: ...
@overload
def expand_dims(
    a: ndarray[*Shape, Dim1, DType], axis: Literal[-2]
) -> ndarray[*Shape, Literal[1], Dim1, DType]: ...
@overload
def expand_dims(a: ndarray[*Shape, DType], axis: Literal[-1]) -> ndarray[*Shape, Literal[1], DType]: ...
@overload
def expand_dims(a: ndarray[*Shape, DType], axis: Literal[0]) -> ndarray[Literal[1], *Shape, DType]: ...
@overload
def expand_dims(a: ndarray[Dim1, *Shape, DType], axis: Literal[1]) -> ndarray[Dim1, Literal[1], *Shape, DType]: ...
@overload
def expand_dims(
    a: ndarray[Dim1, Dim2, *Shape, DType], axis: Literal[2]
) -> ndarray[Dim1, Dim2, Literal[1], *Shape, DType]: ...
@overload
def expand_dims(
    a: ndarray[Dim1, DType], axis: tuple[Literal[0], Literal[2]]
) -> ndarray[Literal[1], Dim1, Literal[1], DType]: ...
def take_along_axis(
    a: ndarray[*Shape, Dim1, DType], indices: ndarray[*Shape, Dim2, Int], axis: Literal[1]
) -> ndarray[*Shape, Dim2, DType]: ...
@overload
def argmax(a: ndarray[Dim1, DType]) -> ndarray[Fin[Dim1]]: ...
@overload
def argmax(a: ndarray[*Shape, Dim1, DType], axis: Literal[-1]) -> ndarray[*Shape, Fin[Dim1]]: ...
@overload
def argmax(a: ndarray[Dim1, Dim2, *Shape, float], axis: Literal[1]) -> ndarray[Dim1, *Shape, Fin[Dim2]]: ...
def multiply(x1: ndarray[Dim1, One, DType], x2: ndarray[One, Dim2, DType]) -> ndarray[Dim1, Dim2, DType]: ...
def tanh(x: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...
def triu(m: ndarray[Dim1, Dim1, DType], k: int = 0) -> ndarray[Dim1, Dim1, DType]: ...
def tril(m: ndarray[Dim1, Dim1, DType], k: int = 0) -> ndarray[Dim1, Dim1, DType]: ...
def prod(a: tuple[int, ...]) -> int: ...
@overload
def pad(
    array: ndarray[Dim1, Dim2, DType],
    pad_width: tuple[tuple[Literal[0], Literal[0]], tuple[int, int]],
    constant_values: DType,
    mode: Literal["constant"] = "constant",
) -> ndarray[Dim1, int, DType]: ...
@overload
def pad(
    array: ndarray[Dim1, DType],
    pad_width: tuple[int, int],
    constant_values: DType,
    mode: Literal["constant"] = "constant",
) -> ndarray[int, DType]: ...
@overload
def pad(
    array: ndarray[*Shape, DType],
    pad_width: Sequence[tuple[int, int]],
    constant_values: DType,
    model: Literal["constant"] = "constant",
) -> ndarray[*tuple[int, ...], DType]: ...
@overload
def all(a: ndarray[*Shape, Dim1, bool], axis: Literal[-1]) -> ndarray[*Shape, bool]: ...
@overload
def all(a: ndarray[*Shape, bool]) -> ndarray[bool]: ...
def roll(a: ndarray[*Shape, DType], shift: int, axis: int) -> ndarray[*Shape, DType]: ...
def split(ary: ndarray[Dim1, DType], indices_or_sections: int) -> list[ndarray[int, DType]]: ...

Repeat = TypeVar("Repeat", bound=int)

def repeat(
    a: ndarray[One, Dim1, Dim2, DType], repeats: Repeat, axis: Literal[-3]
) -> ndarray[Repeat, Dim1, Dim2, DType]: ...
def convolve(
    a: ndarray[int, DType],
    v: ndarray[int, DType],
    mode: Literal["full", "same", "valid"] = "full",
) -> ndarray[int, DType]: ...
def exp(x: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...
def square(x: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...
@overload
def max(
    a: ndarray[*Shape, Float],
    where: ndarray[*Shape, bool] | None = None,
    initial: Float | ndarray[Float] | None = None,
) -> ndarray[Float]: ...
@overload
def max(
    a: ndarray[*Shape, Dim1, Float], axis: Literal[-1], keepdims: Literal[True]
) -> ndarray[*Shape, Literal[1], Float]: ...
@overload
def max(a: ndarray[Dim1, *Shape, Float], axis: Literal[0]) -> ndarray[*Shape, Float]: ...
@overload
def max(
    a: ndarray[Dim1, Dim2, *Shape, Float], axis: Literal[1], where: ndarray[Dim1, Dim2, *Shape, bool] | None = None
) -> ndarray[Dim1, *Shape, Float]: ...
def maximum(x1: ndarray[*Shape, Float], x2: Float | int | ndarray[Float]) -> ndarray[*Shape, Float]: ...
def minimum(x1: ndarray[*Shape, Float], x2: Float | int | ndarray[Float]) -> ndarray[*Shape, Float]: ...
def min(a: ndarray[*Shape, Float]) -> ndarray[Float]: ...
def std(a: ndarray[*Shape, Float]) -> ndarray[Float]: ...
def isclose(a: ndarray[*Shape, Float], b: Float, atol: float) -> ndarray[*Shape, bool]: ...
@overload
def median(a: ndarray[*Shape, Float]) -> ndarray[Float]: ...
@overload
def median(a: ndarray[Dim1, Dim2, *Shape, Float], axis: Literal[1]) -> ndarray[Dim1, *Shape, Float]: ...
@overload
def concatenate(  # pyright: ignore[reportOverlappingOverload]
    arrays: tuple[ndarray[Dim1, *Shape, DType], ndarray[Dim2, *Shape, DType]], axis: Literal[0]
) -> ndarray[Sum[Dim1, Dim2], *Shape, DType]: ...
@overload
def concatenate(
    arrays: tuple[ndarray[Dim1, *Shape, DType], ndarray[Dim2, *Shape, DType], ndarray[Dim3, *Shape, DType]],
    axis: Literal[0],
) -> ndarray[Sum[Dim1, Dim2, Dim3], *Shape, DType]: ...
@overload
def concatenate(
    arrays: Sequence[ndarray[Any, *Shape, DType]], axis: Literal[0]
) -> ndarray[int, *Shape, DType]: ...
@overload
def concatenate(
    arrays: tuple[ndarray[Dim1, Dim2, *Shape, DType], ndarray[Dim1, Dim3, *Shape, DType]], axis: Literal[1]
) -> ndarray[Dim1, Sum[Dim2, Dim3], *Shape, DType]: ...
def transpose(a: ndarray[Dim1, Dim2, DType]) -> ndarray[Dim2, Dim1, DType]: ...
def flip(a: ndarray[*Shape, DType], axis: int) -> ndarray[*Shape, DType]: ...
@overload
def any(a: ndarray[*Shape, bool]) -> ndarray[bool]: ...
@overload
def any(a: ndarray[*Shape, Dim1, bool], axis: Literal[-1]) -> ndarray[*Shape, bool]: ...
@overload
def any(a: ndarray[Dim1, Dim2, *Shape, bool], axis: Literal[1]) -> ndarray[Dim1, *Shape, bool]: ...
def isnan(x: ndarray[*Shape, Float]) -> ndarray[*Shape, bool]: ...
def allclose(a: ndarray[*Shape, Float], b: ndarray[*Shape, Float], atol: float = 1e-8) -> bool: ...
@overload
def bincount(x: Sequence[int]) -> ndarray[int, int]: ...
@overload
def bincount(x: Sequence[int], minlength: Dim1) -> ndarray[Dim1, int]: ...
@overload
def tile(A: ndarray[Dim1, Dim2, DType], reps: tuple[Literal[1], int]) -> ndarray[Dim1, int, DType]: ...
@overload
def tile(A: ndarray[Dim1, DType], reps: tuple[Dim2, Literal[1]]) -> ndarray[Dim2, Dim1, DType]: ...
@overload
def tile(
    A: ndarray[Dim1, Dim2, DType], reps: tuple[Dim3, Literal[1], Literal[1]]
) -> ndarray[Dim3, Dim1, Dim2, DType]: ...
def delete(
    arr: ndarray[int, *Shape, DType], obj: ndarray[int, int], axis: Literal[0]
) -> ndarray[int, *Shape, DType]: ...
def partition(a: ndarray[*Shape, DType], kth: int) -> ndarray[*Shape, DType]: ...
def argpartition(a: ndarray[Dim1, DType], kth: int) -> ndarray[Dim1, Fin[Dim1]]: ...
@overload
def broadcast_to(array: ndarray[DType], shape: tuple[*Shape]) -> ndarray[*Shape, DType]: ...
@overload
def broadcast_to(array: ndarray[Dim1, One, DType], shape: tuple[Dim1, Dim2]) -> ndarray[Dim1, Dim2, DType]: ...
@overload
def isin(element: ndarray[*Shape, DType], test_elements: ndarray[*Shape2, DType2]) -> ndarray[*Shape, bool]: ...
@overload
def isin(element: ndarray[*Shape, DType], test_elements: Collection[DType]) -> ndarray[*Shape, bool]: ...
@overload
def isin(element: Sequence[DType], test_elements: Collection[DType]) -> ndarray[int, bool]: ...
def empty_like(a: ndarray[*Shape, DType2], dtype: type[DType]) -> ndarray[*Shape, DType]: ...
def nan_to_num(x: ndarray[*Shape, Float], nan: Float) -> ndarray[*Shape, Float]: ...
def ones_like(a: ndarray[*Shape, DType], dtype: type[DType2]) -> ndarray[*Shape, DType2]: ...
def tril_indices(n: Dim1, k: int = 0) -> tuple[ndarray[int, Fin[Dim1]], ndarray[int, Fin[Dim1]]]: ...
@overload
def corrcoef(
    x: ndarray[Dim1, Float] | Sequence[Float], y: ndarray[Dim1, Float] | Sequence[Float]
) -> ndarray[Dim1, Dim1, Float]: ...
@overload
def corrcoef(x: ndarray[Dim1, Dim2, Float], rowvar: Literal[False]) -> ndarray[Dim2, Dim2, Float]: ...
@overload
def average(
    a: ndarray[Dim1, Dim2, *Shape, Float], weights: ndarray[Dim1, Dim2, *Shape, Float], axis: Literal[1]
) -> ndarray[Dim1, *Shape, Float]: ...
@overload
def average(a: list[Float], weights: list[Float], axis: Literal[0]) -> ndarray[Float]: ...
def absolute(x: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...
def abs(x: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...
def frombuffer(buffer: bytes, dtype: type[DType]) -> ndarray[int, DType]: ...
def unique(ar: list[DType], return_index: Literal[True]) -> tuple[ndarray[int, DType], ndarray[int, int]]: ...
def append(arr: ndarray[Dim1, DType], values: ndarray[DType] | ndarray[Dim2, DType]) -> ndarray[int, DType]: ...
@overload
def sqrt(x: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...
@overload
def sqrt(x: int) -> ndarray[float32]: ...
def nextafter(x1: ndarray[*Shape, Float], x2: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...
def logical_not(x: ndarray[*Shape, bool]) -> ndarray[*Shape, bool]: ...
def isinf(x: ndarray[*Shape, Float]) -> ndarray[*Shape, bool]: ...
def take(a: ndarray[*tuple[Any, ...], DType], indices: int, axis: int) -> ndarray[*tuple[int, ...], DType]: ...
def eye(N: Dim1, dtype: type[DType]) -> ndarray[Dim1, Dim1, DType]: ...
def reshape(a: ndarray[*Shape, DType], newshape: tuple[*Shape2]) -> ndarray[*Shape2, DType]: ...
def sign(x: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...
@overload
def squeeze(x: ndarray[One, DType]) -> ndarray[DType]: ...
@overload
def squeeze(x: ndarray[One, *Shape, DType], axis: Literal[0]) -> ndarray[*Shape, DType]: ...
@overload
def squeeze(x: ndarray[Dim1, One, *Shape, DType], axis: Literal[1]) -> ndarray[Dim1, *Shape, DType]: ...
def ptp(a: ndarray[*Shape, Float]) -> ndarray[Float]: ...
def round(a: ndarray[*Shape, Float]) -> ndarray[*Shape, Float]: ...

newaxis: None

class floating(float): ...
class float64(floating): ...
class float32(floating): ...
class float16(floating): ...
class int8(int): ...
class int16(int): ...
class int32(int): ...
class bfloat16(floating): ...

def issubdtype(arg1: type[DType], arg2: type[DType2]) -> bool: ...
def load(file: BinaryIO) -> ndarray[*tuple[Any, ...], Any]: ...
def save(file: BinaryIO | str, arr: ndarray[*tuple[Any, ...], Any]) -> None: ...

nan: float
inf: float

class finfo(Generic[DType]):
    def __init__(self, dtype: type[DType]) -> None: ...
    max: DType
    min: DType
    eps: DType
    bits: int
